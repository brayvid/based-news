<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>S&P 500 Forecast | Based News</title>
  <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}" sizes="any">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <style>
    :root { color-scheme: dark; }
    body { margin: 0; font-family: 'Open Sans', sans-serif; background-color: #121212; color: #e0e0e0; line-height: 1.6; overscroll-behavior-x: none; }
    .container { width: 90%; max-width: 800px; margin: 0 auto; padding-top: 4px; }
    header { background-color: #121212; padding: 1.5em 0; text-align: center; }
    header h1 { margin: 0; font-family: 'Merriweather', serif; font-size: clamp(1.8em, 8vw, 2.5em); color: #e0e0e0; cursor: pointer; }
    header h1:hover { text-decoration: underline; }
    header h1 a { color: inherit; text-decoration: none; }
    .subheading { margin-top: 0.5em; font-size: 1.1em; color: #bbb; }
    
    main { background: #1e1e1e; border: 1px solid #333; margin-top: 2em; padding: 2em 1.6em; }
    .prediction-card { padding: 0; margin: 0; }
    .card-header { border-bottom: 1px solid #444; padding-bottom: 0.8em; margin-bottom: 1em; }
    .prediction-details { display: flex; justify-content: space-between; align-items: center; margin-top: 0.5em; flex-wrap: wrap; }
    .prediction-signal { font-size: 1.5em; font-weight: bold; }
    .prediction-up { color: #4CAF50; }
    .prediction-down { color: #F44336; }
    .confidence { font-size: 1.2em; color: #ccc; }
    .chart-container { position: relative; height: 300px; margin-top: 1.5em; }
    footer { text-align: center; font-size: 0.9em; color: #999; padding: 2em 0; }
    footer a { color: #8ab4f8; }

    .forecast-pagination { display: flex; justify-content: center; align-items: center; gap: 8px; margin-bottom: 1em; margin-top: 1em; user-select: none; }
    .arrow-btn { background-color: transparent; border: none; color: #aaa; font-size: 18px; cursor: pointer; padding: 5px; line-height: 1; transition: color 0.2s; }
    .arrow-btn:hover:not(:disabled) { color: #fff; }
    .arrow-btn:disabled { opacity: 0.3; cursor: not-allowed; }
    #dots-container { display: flex; align-items: center; gap: 12px; }
    .dot { width: 10px; height: 10px; background-color: #555; border-radius: 50%; cursor: pointer; transition: background-color 0.2s, transform 0.2s; flex-shrink: 0; }
    .dot.active { background-color: #4a90e2; transform: scale(1.2); }
    .forecast-timestamp { font-family: 'Merriweather', serif; font-size: 1.1em; text-align: center; color: #ccc; margin-bottom: 1em; border-bottom: 1px solid #444; padding-bottom: 0.5em; }
    #forecast-slider-wrapper { overflow: hidden; position: relative; width: 100%; transition: height 0.25s ease-in-out; min-height: 400px; padding-bottom: 1em; }
    #forecast-slider { display: flex; transition: transform 0.4s ease-in-out; align-items: flex-start; }
    .forecast-slide { width: 100%; flex-shrink: 0; box-sizing: border-box; }

    @media (max-width: 600px) {
        main { padding: 1.2em 1em; }
        .prediction-details { flex-direction: column; align-items: flex-start; gap: 0.25em; }
        .prediction-signal { font-size: 1.2em; }
        .confidence { font-size: 1.0em; }
    }
  </style>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Merriweather:wght@400;700&family=Open+Sans:wght@400;600&display=swap" media="print" onload="this.media='all'" />
</head>
<body>
  <header>
    <div class="container">
      <h1><a href="{{ url_for('index') }}">Based News Reader</a></h1>
      <p class="subheading">S&P 500 forecast updated weekdays shortly before market open.</p>
    </div>
  </header>

  <main class="container">
    {% if predictions %}
        <div class="forecast-pagination">
          <button id="older-btn" class="arrow-btn" disabled title="Older Forecast">◄</button>
          <div id="dots-container"></div>
          <button id="newer-btn" class="arrow-btn" disabled title="Newer Forecast">►</button>
        </div>
        <p id="forecast-timestamp-header" class="forecast-timestamp"></p>
        
        <div id="forecast-slider-wrapper">
            <div id="forecast-slider">
                {% for prediction in predictions | reverse %}
                <div class="forecast-slide">
                    <div class="prediction-card">
                        <div class="card-header">
                            <div class="prediction-details">
                                {% if prediction.direction == 'UP' %}
                                    <span class="prediction-signal prediction-up">1-WEEK FORECAST: HIGHER ↑</span>
                                {% else %}
                                    <span class="prediction-signal prediction-down">1-WEEK FORECAST: LOWER ↓</span>
                                {% endif %}
                                <span class="confidence">Confidence: {{ "%.1f"|format(prediction.confidence * 100) }}%</span>
                            </div>
                        </div>
                        
                        <div class="chart-container">
                            <canvas id="forecast-chart-{{ loop.index0 }}"></canvas>
                        </div>
                    </div>
                </div>
                {% endfor %}
            </div>
        </div>
    {% else %}
        <p>No forecasts found. Forecasts generated on weekdays shortly before market open.</p>
    {% endif %}
  </main>

  <footer>
    <div class="container">
      <p><a href="/">Home</a> | <a href="https://docs.google.com/spreadsheets/d/1OjpsQEnrNwcXEWYuPskGRA5Jf-U8e_x0x3j2CKJualg/edit?usp=sharing">Settings</a> | <a href="https://github.com/brayvid/based-news">GitHub</a> | <a href="https://blakerayvid.com">Portfolio</a></p>
    </div>
  </footer>
  
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- NOTE: Date FNS adapter removed as we are now using category axis for manual spacing -->
  
  <script>
    document.addEventListener('DOMContentLoaded', function() {
        const jsonString = '{{ predictions | tojson | safe }}';
        if (!jsonString || jsonString === 'null' || jsonString === '[]') return;
        
        const predictionsData = JSON.parse(jsonString).reverse();

        const forecastSliderWrapper = document.getElementById("forecast-slider-wrapper");
        const forecastSlider = document.getElementById("forecast-slider");
        const olderBtn = document.getElementById("older-btn");
        const newerBtn = document.getElementById("newer-btn");
        const dotsContainer = document.getElementById("dots-container");
        const timestampHeader = document.getElementById("forecast-timestamp-header");

        let chartInstances = [];
        let currentIndex = 0;
        let totalItems = predictionsData.length;
        let touchStartX = 0;
        let touchEndX = 0;
        const swipeThreshold = 50;
        
        // Helper to format timestamps into strings for the Category Axis
        function formatDateLabel(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        }

        // Helper to get next business day (skips Sat/Sun)
        function getNextBusinessDay(dateObj) {
            let d = new Date(dateObj);
            do {
                d.setDate(d.getDate() + 1);
            } while (d.getDay() === 0 || d.getDay() === 6);
            return d;
        }

        function renderChart(index) {
            if (chartInstances[index] || !predictionsData[index]) return;

            const prediction = predictionsData[index];
            const ctx = document.getElementById('forecast-chart-' + index);
            if (!ctx) return;

            const chartData = prediction.chart_data;
            if (!chartData || !chartData.points || chartData.points.length === 0) {
                if (ctx.parentElement) ctx.parentElement.style.display = 'none';
                return;
            }

            const tzOffsetMs = new Date().getTimezoneOffset() * 60 * 1000;
            
            // 1. Prepare Historical Data and Labels
            const labels = [];
            const histData = [];
            
            chartData.points.forEach(p => {
                // Adjust for timezone to ensure date string consistency
                const localTs = p.x + tzOffsetMs; 
                labels.push(formatDateLabel(localTs));
                histData.push(p.y);
            });

            // 2. Prepare Forecast Target
            const lastHistVal = histData[histData.length - 1];
            const lastHistDateTs = chartData.points[chartData.points.length - 1].x + tzOffsetMs;
            
            const forecastPct = prediction.direction === 'UP' ? 1.015 : 0.985;
            const forecastTarget = lastHistVal * forecastPct;

            // 3. Generate Future Labels (Business Days Only)
            let currentDateObj = new Date(lastHistDateTs);
            for(let i=0; i<5; i++) {
                currentDateObj = getNextBusinessDay(currentDateObj);
                labels.push(formatDateLabel(currentDateObj));
            }

            // 4. Prepare Forecast Data Array
            // Fill with nulls for historical period, set start point at last history index
            const forecastData = new Array(histData.length).fill(null);
            forecastData[histData.length - 1] = lastHistVal; // Connect the lines
            
            // Fill empty slots for intermediate forecast days (for alignment)
            for(let i=0; i<4; i++) {
                forecastData.push(null);
            }
            // Add the final target
            forecastData.push(forecastTarget);

            chartInstances[index] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels, // Shared strings array
                    datasets: [
                        { 
                            label: 'SPY', 
                            data: histData, 
                            borderColor: '#aaaaaa', 
                            borderWidth: 2, 
                            pointRadius: 0, 
                            tension: 0.1 
                        },
                        { 
                            label: 'Forecast', 
                            data: forecastData, 
                            borderColor: prediction.direction === 'UP' ? 'rgba(80, 160, 115, 0.8)' : 'rgba(215, 85, 65, 0.8)', 
                            borderWidth: 2, 
                            borderDash: [5, 5], 
                            pointRadius: 0, 
                            tension: 0,
                            spanGaps: true // Crucial: Draws line over the nulls in forecast period
                        }
                    ]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    scales: {
                        x: { 
                            type: 'category', // Even spacing, no gaps for weekends
                            grid: { color: 'rgba(255,255,255,0.1)' }, 
                            ticks: { 
                                color: '#ccc', 
                                maxRotation: 0, 
                                autoSkip: true, 
                                maxTicksLimit: 6 
                            } 
                        },
                        y: { 
                            position: 'right', 
                            grid: { color: 'rgba(255,255,255,0.1)' }, 
                            ticks: { color: '#ccc' } 
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            align: 'start',
                            labels: {
                                color: '#ccc',
                                usePointStyle: true,
                                pointStyle: 'line',
                                useBorderDash: true,
                                boxWidth: 20,
                                padding: 20
                            }
                        },
                        tooltip: {
                            intersect: false,
                            mode: 'index', // Show both lines at specific X index
                            displayColors: false
                        }
                    }
                }
            });
        }
        
        function updateNavControls() {
            olderBtn.disabled = currentIndex <= 0;
            newerBtn.disabled = currentIndex >= totalItems - 1;
            document.querySelectorAll('.dot').forEach((dot, idx) => dot.classList.toggle('active', idx === currentIndex));
        }

        function updateTimestampHeader() {
            const prediction = predictionsData[currentIndex];
            if (prediction && prediction.news_date_formatted) {
                timestampHeader.textContent = prediction.news_date_formatted;
            }
        }

        function adjustWrapperHeight() {
            const currentSlide = forecastSlider.children[currentIndex];
            if (currentSlide) requestAnimationFrame(() => { forecastSliderWrapper.style.height = `${currentSlide.offsetHeight}px`; });
        }

        function showForecast(index) {
            if (index < 0 || index >= totalItems) return;
            currentIndex = index;
            forecastSlider.style.transform = `translateX(-${index * 100}%)`;
            updateNavControls();
            updateTimestampHeader();
            renderChart(index);
            adjustWrapperHeight();
        }
        
        function handleSwipe() {
            const deltaX = touchEndX - touchStartX;
            if (Math.abs(deltaX) > swipeThreshold) {
                if (deltaX < 0 && currentIndex < totalItems - 1) showForecast(currentIndex + 1);
                else if (deltaX > 0 && currentIndex > 0) showForecast(currentIndex - 1);
            }
        }

        function initializeCarousel() {
            if (totalItems === 0) return;
            
            dotsContainer.innerHTML = '';
            for (let i = 0; i < totalItems; i++) {
                const dot = document.createElement('div');
                dot.className = 'dot';
                dot.onclick = () => showForecast(i);
                dotsContainer.appendChild(dot);
                chartInstances.push(null);
            }

            olderBtn.onclick = () => { if (currentIndex > 0) showForecast(currentIndex - 1); };
            newerBtn.onclick = () => { if (currentIndex < totalItems - 1) showForecast(currentIndex + 1); };

            forecastSliderWrapper.addEventListener('touchstart', e => { touchStartX = e.changedTouches[0].screenX; }, { passive: true });
            forecastSliderWrapper.addEventListener('touchend', e => { touchEndX = e.changedTouches[0].screenX; handleSwipe(); });
            
            window.addEventListener('resize', adjustWrapperHeight);
            
            showForecast(totalItems - 1); 
        }
        
        initializeCarousel();
    });
  </script>
</body>
</html>